#lang racket

(define (min a b)
  (if (< a b)
      a
      b))
(define (doWork a b result)
  (define (find-min x nowmin now)
    (if (= now (- (length x) 1))
        (min nowmin (list-ref x now))
        (if (< (list-ref x now) nowmin)
            (find-min x (list-ref x now) (+ now 1))
            (find-min x nowmin (+ now 1)))))
  (cond ((and (empty? a) (empty? b)) (displayln result))
        ((empty? a)
         (define minb (find-min b (car b) 0))
         (define minNumber minb)
         (doWork (filter (lambda (num) (not (= num minNumber))) a) (filter (lambda (num) (not (= num minNumber))) b) (append result (list minNumber))))
        ((empty? b)
         (define mina (find-min a (car a) 0))
         (define minNumber mina)
         (doWork (filter (lambda (num) (not (= num minNumber))) a) (filter (lambda (num) (not (= num minNumber))) b) (append result (list minNumber))))
        (else
         (define mina (find-min a (car a) 0))
         (define minb (find-min b (car b) 0))
         (define minNumber (min mina minb))
         (doWork (filter (lambda (num) (not (= num minNumber))) a) (filter (lambda (num) (not (= num minNumber))) b) (append result (list minNumber))))))
(define (myloop)
  (let ((a (read))
        (b (read)))
    (if (eq? a eof)
        (void)
        (begin (doWork a b (list)) (myloop)))))
(myloop)
