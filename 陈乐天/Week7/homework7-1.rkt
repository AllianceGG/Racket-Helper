#lang racket
(require scheme/mpair)

(define map-graph (mlist))
(define row 0)
(define column 0)
(define pace 0)
(define four-direction (list (cons 1 0) (cons 0 1) (cons -1 0) (cons 0 -1)))
(define answer 100000000)
(define (update-answer now-answer)
  (if (< now-answer answer)
      (set! answer now-answer)
      (void)))

; start with 0
(define (get-map-graph x y)
  (mlist-ref (mlist-ref map-graph x) y))
(define (set-map-graph x y new-value)
  (define (find-map-graph-y map-graph now-y)
    (if (= now-y y)
        (set-mcar! map-graph new-value)
        (find-map-graph-y (mcdr map-graph) (+ now-y 1))))
  (define (find-map-graph-x map-graph now-x)
    (if (= now-x x)
        (find-map-graph-y (mcar map-graph) 0)
        (find-map-graph-x (mcdr map-graph) (+ now-x 1))))
  (find-map-graph-x map-graph 0))

(define (doWork)
  (define (find-path now-x now-y depth)
    (define (try-path now-direction)
      (if (= now-direction 4)
          (void)
          (let ((direction (list-ref four-direction now-direction)))
            (let ((new-x (+ now-x (car direction)))
                  (new-y (+ now-y (cdr direction))))
              (if (and (>= new-x 0) (>= new-y 0) (< new-x row) (< new-y column))
                  (let ((new-status (get-map-graph new-x new-y)))
                    (cond
                      ((equal? new-status 'W) (try-path (+ now-direction 1)))
                      ((equal? new-status 'B)
                       (begin
                         (set-map-graph new-x new-y 'W)
                         (find-path new-x new-y (+ depth 1))
                         (set-map-graph new-x new-y 'B)
                         (try-path (+ now-direction 1))))
                      ((equal? new-status 'M)
                       (if (> pace 0)
                           (begin
                             (set-map-graph new-x new-y 'W)
                             (set! pace (- pace 1))
                             (find-path new-x new-y (+ depth 1))
                             (set-map-graph new-x new-y 'M)
                             (set! pace (+ pace 1))
                             (try-path (+ now-direction 1)))
                           (try-path (+ now-direction 1))))))
                  (try-path (+ now-direction 1)))))))
    (if (and (= now-x (- row 1)) (= now-y (- column 1)))
        (update-answer depth)
        (try-path 0)))
  (find-path 0 0 0)
  (if (= answer 100000000)
      (displayln 'inf)
      (displayln answer)))


(define n (read))

(define (myloop i)
  (if (= i n)
      (void)
      (begin
        (let ((r (read))
              (c (read))
              (k (read)))
          (define (input-row row)
            (define (input-column column)
              (if (= column c)
                  '()
                  (mcons (read) (input-column (+ column 1)))))
            (if (= row r)
                '()
                (mcons (input-column 0) (input-row (+ row 1)))))
          (set! map-graph (input-row 0))
          (set! row r)
          (set! column c)
          (set! pace k)
          (set! answer 100000000)
          (doWork))
        (myloop (+ 1 i)))))
(myloop 0)