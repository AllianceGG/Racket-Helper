#lang racket
(define (map op lst)
  (if (null? lst)
      '()
      (cons (op (car lst))
            (map op (cdr lst)))))

(define (super-map op . w)
  (define (for idx end fun)
    (if (= idx end)
        (void)
        (begin (fun idx)
               (for (+ 1 idx) end fun))))
  (define lists (list->vector w))
  (define count (vector-length lists))
  (define ret (vector))
  (define opArgs empty)
  (if (= 0 count)
      empty
      (begin 
        (for 0 (length (vector-ref lists 0))
          (lambda (i)
            (begin (set! opArgs empty)
                   (for 0 count
                     (lambda (j)
                       (set! opArgs (append opArgs (list (list-ref (vector-ref lists j) i))))
                       ))
                   (set! ret (vector-append ret (vector (apply op opArgs)))))
            
            ))
        (vector->list ret)
        ))
  )

(define (myloop)
  (let ((a (read))
        (b (read))
        (c (read)))
    (if (eq? a eof)
        (void)
        (begin (displayln (super-map + a b c)) 
               (displayln (super-map (lambda (x y) (+ x (* 2 y) )) a b ))
               (myloop)))))
(myloop)