#lang racket
(require scheme/mpair)

(define (insertbehind node value)
  (define newnode (mcons value (mcdr node)))
  (set-mcdr! node newnode)
  null)
(define (cmp node value)
  (define nodevalue (mcar node))
  (cond((< nodevalue value) -1)
       ((= nodevalue value) 0)
       ((> nodevalue value) 1)))
(define (insert2rightplace nodelist value)
  (define nextnode (mcdr nodelist))
  (if(null? nextnode)
     (insertbehind nodelist value)
     (let ((cmpvalue (cmp nextnode value)))
       (cond((= cmpvalue -1) (insert2rightplace nextnode value))
            ((= cmpvalue 0) null)
            ((= cmpvalue 1) (insertbehind nodelist value))))))
(define (printresult nodelist)
  (define nextnode (mcdr nodelist))
  (if(null? nextnode)
     (void)
     (begin
       (display " ")
       (display (mcar nextnode))
       (printresult nextnode))))

(define result (mcons null null))
(define (mainloop)
  (define nextvalue (read))
  (if(equal? nextvalue eof)
     (void)
     (begin
       (insert2rightplace result nextvalue)
       (mainloop))))
(mainloop)
(display (mcar (mcdr result)))
(define nextnode (mcdr result))
(if(null? nextnode)
   (void)
   (printresult nextnode))
